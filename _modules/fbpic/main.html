

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>fbpic.main &mdash; FBPIC 0.15.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/language_data.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> FBPIC
          

          
          </a>

          
            
            
              <div class="version">
                0.15.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../overview/overview.html">Overview of the code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install/installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../how_to_run.html">How to run the code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api_reference/api_reference.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../advanced/advanced.html">Advanced use</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">FBPIC</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>fbpic.main</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for fbpic.main</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2016, FBPIC contributors</span>
<span class="c1"># Authors: Remi Lehe, Manuel Kirchen, Kevin Peters, Soeren Jalas</span>
<span class="c1"># License: 3-Clause-BSD-LBNL</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Fourier-Bessel Particle-In-Cell (FB-PIC) main file</span>

<span class="sd">This file steers and controls the simulation.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># When cuda is available, select one GPU per mpi process</span>
<span class="c1"># (This needs to be done before the other imports,</span>
<span class="c1"># as it sets the cuda context)</span>
<span class="kn">from</span> <span class="nn">fbpic.utils.mpi</span> <span class="kn">import</span> <span class="n">MPI</span>
<span class="c1"># Check if threading is available</span>
<span class="kn">from</span> <span class="nn">.utils.threading</span> <span class="kn">import</span> <span class="n">threading_enabled</span><span class="p">,</span> <span class="n">numba_minor_version</span>
<span class="c1"># Check if CUDA is available, then import CUDA functions</span>
<span class="kn">from</span> <span class="nn">.utils.cuda</span> <span class="kn">import</span> <span class="n">cuda_installed</span><span class="p">,</span> <span class="n">cupy_installed</span><span class="p">,</span> <span class="n">cupy_major_version</span>
<span class="k">if</span> <span class="n">cuda_installed</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.utils.cuda</span> <span class="kn">import</span> <span class="n">send_data_to_gpu</span><span class="p">,</span> \
                <span class="n">receive_data_from_gpu</span><span class="p">,</span> <span class="n">mpi_select_gpus</span>
    <span class="n">mpi_select_gpus</span><span class="p">(</span> <span class="n">MPI</span> <span class="p">)</span>

<span class="c1"># Import the rest of the requirements</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numba</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy.constants</span> <span class="kn">import</span> <span class="n">m_e</span><span class="p">,</span> <span class="n">m_p</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">c</span>
<span class="kn">from</span> <span class="nn">.utils.printing</span> <span class="kn">import</span> <span class="n">ProgressBar</span><span class="p">,</span> <span class="n">print_simulation_setup</span>
<span class="kn">from</span> <span class="nn">.particles</span> <span class="kn">import</span> <span class="n">Particles</span>
<span class="kn">from</span> <span class="nn">.lpa_utils.boosted_frame</span> <span class="kn">import</span> <span class="n">BoostConverter</span>
<span class="kn">from</span> <span class="nn">.fields</span> <span class="kn">import</span> <span class="n">Fields</span>
<span class="kn">from</span> <span class="nn">.boundaries</span> <span class="kn">import</span> <span class="n">BoundaryCommunicator</span><span class="p">,</span> <span class="n">MovingWindow</span>

<div class="viewcode-block" id="Simulation"><a class="viewcode-back" href="../../api_reference/simulation.html#fbpic.main.Simulation">[docs]</a><span class="k">class</span> <span class="nc">Simulation</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Top-level simulation class that contains all the simulation</span>
<span class="sd">    data, as well as the methods to perform the PIC cycle.</span>

<span class="sd">    The `Simulation` class has several important attributes:</span>

<span class="sd">    - `fld`, a `Fields` object which contains the field information</span>
<span class="sd">    - `ptcl`, a list of `Particles` objects (one per species)</span>
<span class="sd">    - `diags`, a list of diagnostics to be run during the simulation</span>
<span class="sd">    - `comm`, a `BoundaryCommunicator`, which contains the MPI decomposition</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Nz</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">Nr</span><span class="p">,</span> <span class="n">rmax</span><span class="p">,</span> <span class="n">Nm</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span>
                 <span class="n">p_zmin</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">p_zmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">p_rmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">p_rmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                 <span class="n">p_nz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p_nr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p_nt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n_e</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">zmin</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
                 <span class="n">n_order</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dens_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filter_currents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">v_comoving</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_galilean</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">initialize_ions</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_cuda</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">n_guard</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_damp</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span><span class="mi">64</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span><span class="mi">32</span><span class="p">},</span>
                 <span class="n">exchange_period</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">current_correction</span><span class="o">=</span><span class="s1">&#39;curl-free&#39;</span><span class="p">,</span>
                 <span class="n">boundaries</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;z&#39;</span><span class="p">:</span><span class="s1">&#39;periodic&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span><span class="s1">&#39;reflective&#39;</span><span class="p">},</span>
                 <span class="n">gamma_boost</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_all_mpi_ranks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">particle_shape</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">verbose_level</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                 <span class="n">smoother</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a simulation.</span>

<span class="sd">        By default, this will not create any particle species. You can</span>
<span class="sd">        then add particles species to the simulation by using e.g. the method</span>
<span class="sd">        ``add_new_species`` of the simulation object.</span>

<span class="sd">        .. note::</span>

<span class="sd">            As a short-cut, you can also directly create particle</span>
<span class="sd">            species when initializing the ``Simulation`` object,</span>
<span class="sd">            by passing the aguments `n_e`, `p_rmin`, `p_rmax`, `p_nz`,</span>
<span class="sd">            `p_nr`, `p_nt`, and `dens_func`. This will create:</span>

<span class="sd">                - an electron species</span>
<span class="sd">                - (if ``initialize_ions`` is True) an ion species (Hydrogen 1+)</span>

<span class="sd">            See the docstring of the method ``add_new_species`` for the</span>
<span class="sd">            above-mentioned arguments (where `n_e` has been re-labeled as `n`).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Nz: int</span>
<span class="sd">            The number of gridpoints along z</span>
<span class="sd">        Nr: int</span>
<span class="sd">            The number of gridpoints along r</span>

<span class="sd">        zmax: float</span>
<span class="sd">            The position of the edge of the simulation in z</span>
<span class="sd">            (More precisely, the position of the edge of the last cell)</span>
<span class="sd">        rmax: float</span>
<span class="sd">            The position of the edge of the simulation in r</span>
<span class="sd">            (More precisely, the position of the edge of the last</span>
<span class="sd">            cell)</span>

<span class="sd">        Nm: int</span>
<span class="sd">            The number of azimuthal modes taken into account. (The simulation</span>
<span class="sd">            uses the modes from `m=0` to `m=(Nm-1)`.)</span>

<span class="sd">        dt: float</span>
<span class="sd">            The timestep of the simulation</span>

<span class="sd">        n_order: int, optional</span>
<span class="sd">           The order of the stencil for z derivatives in the Maxwell solver.</span>
<span class="sd">           Use -1 for infinite order, i.e. for exact dispersion relation in</span>
<span class="sd">           all direction (adviced for single-GPU/single-CPU simulation).</span>
<span class="sd">           Use a positive number (and multiple of 2) for a finite-order stencil</span>
<span class="sd">           (required for multi-GPU/multi-CPU with MPI). A large `n_order` leads</span>
<span class="sd">           to more overhead in MPI communications, but also to a more accurate</span>
<span class="sd">           dispersion relation for electromagnetic waves. (Typically,</span>
<span class="sd">           `n_order = 32` is a good trade-off.) See `this article</span>
<span class="sd">           &lt;https://arxiv.org/abs/1611.05712&gt;`_ for more information.</span>

<span class="sd">        zmin: float, optional</span>
<span class="sd">           The position of the edge of the simulation box.</span>
<span class="sd">           (More precisely, the position of the edge of the first cell)</span>

<span class="sd">        initialize_ions: bool, optional</span>
<span class="sd">           Whether to initialize the neutralizing ions</span>
<span class="sd">        filter_currents: bool, optional</span>
<span class="sd">            Whether to filter the currents and charge in k space</span>

<span class="sd">        v_comoving: float or None, optional</span>
<span class="sd">            If this variable is None, the standard PSATD is used (default).</span>
<span class="sd">            Otherwise, the current is assumed to be &quot;comoving&quot;,</span>
<span class="sd">            i.e. constant with respect to (z - v_comoving * t).</span>
<span class="sd">            This can be done in two ways: either by</span>
<span class="sd">            - Using a PSATD scheme that takes this hypothesis into account</span>
<span class="sd">            - Solving the PSATD scheme in a Galilean frame</span>
<span class="sd">        use_galilean: bool, optional</span>
<span class="sd">            Determines which one of the two above schemes is used</span>
<span class="sd">            When use_galilean is true, the whole grid moves</span>
<span class="sd">            with a speed v_comoving</span>

<span class="sd">        use_cuda: bool, optional</span>
<span class="sd">            Whether to use CUDA (GPU) acceleration</span>

<span class="sd">        n_guard: int, optional</span>
<span class="sd">            Number of guard cells to use at the left and right of</span>
<span class="sd">            a domain, when performing parallel (MPI) computation</span>
<span class="sd">            or when using open boundaries. Defaults to None, which</span>
<span class="sd">            calculates the required guard cells for n_order</span>
<span class="sd">            automatically (approx 2*n_order). If no MPI is used and</span>
<span class="sd">            in the case of open boundaries with an infinite order stencil,</span>
<span class="sd">            n_guard defaults to 64, if not set otherwise.</span>
<span class="sd">        n_damp: dict, optional</span>
<span class="sd">            A dictionary with &#39;z&#39; and &#39;r&#39; as keys, and integers as values.</span>
<span class="sd">            The integers represent the number of damping cells in the</span>
<span class="sd">            longitudinal (z) and transverse (r) directions, respectively.</span>
<span class="sd">            The damping cells in z are only used if `boundaries[&#39;z&#39;]` is</span>
<span class="sd">            `&#39;open&#39;`, and are added at the left and right edge of the</span>
<span class="sd">            simulation domain. The damping cells in r are used only if</span>
<span class="sd">            `boundaries[&#39;r&#39;]` is `&#39;open&#39;`, and are added at upper</span>
<span class="sd">            radial boundary (at `rmax`).</span>

<span class="sd">        exchange_period: int, optional</span>
<span class="sd">            Number of iterations before which the particles are exchanged.</span>
<span class="sd">            If set to None, the maximum exchange period is calculated</span>
<span class="sd">            automatically: Within exchange_period timesteps, the</span>
<span class="sd">            particles should never be able to travel more than</span>
<span class="sd">            (n_guard/2 - particle_shape order) cells. (Setting exchange_period</span>
<span class="sd">            to small values can substantially affect the performance)</span>

<span class="sd">        boundaries: dict, optional</span>
<span class="sd">            A dictionary with &#39;z&#39; and &#39;r&#39; as keys, and strings as values.</span>
<span class="sd">            This specifies the field boundary in the longitudinal (z) and</span>
<span class="sd">            transverse (r) direction respectively:</span>
<span class="sd">              - `boundaries[&#39;z&#39;]` can be either `&#39;periodic&#39;` or `&#39;open&#39;`</span>
<span class="sd">                (for field-absorbing boundary).</span>
<span class="sd">              - `boundaries[&#39;r&#39;]` can be either `&#39;reflective&#39;` or `&#39;open&#39;`</span>
<span class="sd">                (for field-absorbing boundary). For `&#39;open&#39;`, this adds</span>
<span class="sd">                Perfectly-Matched-Layers in the radial direction ; note that</span>
<span class="sd">                the computation is significantly more costly in this case.</span>

<span class="sd">        current_correction: string, optional</span>
<span class="sd">            The method used in order to ensure that the continuity equation</span>
<span class="sd">            is satisfied. Either `curl-free` or `cross-deposition`.</span>
<span class="sd">            `curl-free` is faster but less local.</span>

<span class="sd">        gamma_boost : float, optional</span>
<span class="sd">            When running the simulation in a boosted frame, set the</span>
<span class="sd">            value of `gamma_boost` to the corresponding Lorentz factor.</span>
<span class="sd">            All the other quantities (zmin, zmax, n_e, etc.) are to be given</span>
<span class="sd">            in the lab frame.</span>

<span class="sd">        use_all_mpi_ranks: bool, optional</span>
<span class="sd">            When launching the simulation with mpirun:</span>

<span class="sd">            - if `use_all_mpi_ranks` is True (default):</span>
<span class="sd">              All the MPI ranks will contribute to the same simulation,</span>
<span class="sd">              using domain-decomposition to share the work.</span>
<span class="sd">            - if `use_all_mpi_ranks` is False:</span>
<span class="sd">              Each MPI rank will run an independent simulation.</span>
<span class="sd">              This can be useful when running parameter scans. In this case,</span>
<span class="sd">              make sure that your input script is written so that the input</span>
<span class="sd">              parameters and output folder depend on the MPI rank.</span>

<span class="sd">        particle_shape: str, optional</span>
<span class="sd">            Set the particle shape for the charge/current deposition.</span>
<span class="sd">            Possible values are &#39;cubic&#39;, &#39;linear&#39;. (&#39;cubic&#39; corresponds to</span>
<span class="sd">            third order shapes and &#39;linear&#39; to first order shapes).</span>

<span class="sd">        verbose_level: int, optional</span>
<span class="sd">            Print information about the simulation setup after</span>
<span class="sd">            initialization of the Simulation class.</span>
<span class="sd">            0 - Print no information</span>
<span class="sd">            1 (Default) - Print basic information</span>
<span class="sd">            2 - Print detailed information</span>

<span class="sd">        smoother: an instance of :any:`BinomialSmoother`, optional</span>
<span class="sd">            Determines how the charge and currents are smoothed.</span>
<span class="sd">            (Default: one-pass binomial filter and no compensator.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check whether to use CUDA</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_cuda</span> <span class="o">=</span> <span class="n">use_cuda</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_cuda</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cuda_installed</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;Cuda not available for the simulation.</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="s1">&#39;Performing the simulation on CPU.&#39;</span> <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_cuda</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># Check that cupy and numba have the right version</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_cuda</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">cupy_installed</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s1">&#39;In order to run on GPUs, FBPIC version 0.13 and later </span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="s1">&#39;require the `cupy` package.</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="s1">&#39;See the FBPIC documentation in order to install cupy.&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">cupy_major_version</span> <span class="o">&gt;=</span> <span class="mi">7</span> <span class="ow">and</span> <span class="n">numba_minor_version</span> <span class="o">&lt;</span> <span class="mi">46</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s1">&#39;You are using cupy version </span><span class="si">%d</span><span class="s1">.</span><span class="se">\n</span><span class="s1">For compatibility, &#39;</span>
                    <span class="s1">&#39;you need to install numba 0.46 or later.</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="s1">&#39;(Your current version is numba 0.</span><span class="si">%d</span><span class="s1">.)</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="s1">&#39;e.g. with `conda uninstall numba; conda install numba`.&#39;</span>
                    <span class="o">%</span><span class="p">(</span><span class="n">cupy_major_version</span><span class="p">,</span><span class="n">numba_minor_version</span><span class="p">))</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">cupy_major_version</span> <span class="o">&lt;</span> <span class="mi">7</span> <span class="ow">and</span> <span class="n">numba_minor_version</span> <span class="o">&gt;=</span> <span class="mi">46</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="s1">&#39;You are using numba version 0.</span><span class="si">%d</span><span class="s1">.</span><span class="se">\n</span><span class="s1">For compatibility, &#39;</span>
                    <span class="s1">&#39;you need to install cupy 7 or later.</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="s1">&#39;(Your current version is cupy </span><span class="si">%d</span><span class="s1">.)</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="s1">&#39;e.g. with `pip install --upgrade cupy-cudaXXX`</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="s1">&#39;where `XXX` should be replaced by your cuda version.&#39;</span>
                    <span class="o">%</span><span class="p">(</span><span class="n">numba_minor_version</span><span class="p">,</span><span class="n">cupy_major_version</span><span class="p">))</span>
        <span class="c1"># CPU multi-threading</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_threading</span> <span class="o">=</span> <span class="n">threading_enabled</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_threading</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cpu_threads</span> <span class="o">=</span> <span class="n">numba</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">NUMBA_NUM_THREADS</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cpu_threads</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># Register the comoving parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_comoving</span> <span class="o">=</span> <span class="n">v_comoving</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_galilean</span> <span class="o">=</span> <span class="n">use_galilean</span>
        <span class="k">if</span> <span class="n">v_comoving</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">use_galilean</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># When running the simulation in a boosted frame, convert the arguments</span>
        <span class="k">if</span> <span class="n">gamma_boost</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boost</span> <span class="o">=</span> <span class="n">BoostConverter</span><span class="p">(</span> <span class="n">gamma_boost</span> <span class="p">)</span>
            <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boost</span><span class="o">.</span><span class="n">copropag_length</span><span class="p">([</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">dt</span> <span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">boost</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Register time step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="n">dt</span>

        <span class="c1"># Initialize the boundary communicator</span>
        <span class="n">cdt_over_dr</span> <span class="o">=</span> <span class="n">c</span><span class="o">*</span><span class="n">dt</span> <span class="o">/</span> <span class="p">(</span><span class="n">rmax</span><span class="o">/</span><span class="n">Nr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span> <span class="o">=</span> <span class="n">BoundaryCommunicator</span><span class="p">(</span> <span class="n">Nz</span><span class="p">,</span> <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">Nr</span><span class="p">,</span> <span class="n">rmax</span><span class="p">,</span> <span class="n">Nm</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">v_comoving</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_galilean</span><span class="p">,</span> <span class="n">boundaries</span><span class="p">,</span> <span class="n">n_order</span><span class="p">,</span>
            <span class="n">n_guard</span><span class="p">,</span> <span class="n">n_damp</span><span class="p">,</span> <span class="n">cdt_over_dr</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">exchange_period</span><span class="p">,</span>
            <span class="n">use_all_mpi_ranks</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_pml</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">use_pml</span>
        <span class="c1"># Modify domain region</span>
        <span class="n">zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">Nz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">divide_into_domain</span><span class="p">()</span>
        <span class="n">Nr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">get_Nr</span><span class="p">(</span> <span class="n">with_damp</span><span class="o">=</span><span class="kc">True</span> <span class="p">)</span>
        <span class="n">rmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">get_rmax</span><span class="p">(</span> <span class="n">with_damp</span><span class="o">=</span><span class="kc">True</span> <span class="p">)</span>
        <span class="c1"># Initialize the field structure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fld</span> <span class="o">=</span> <span class="n">Fields</span><span class="p">(</span> <span class="n">Nz</span><span class="p">,</span> <span class="n">zmax</span><span class="p">,</span> <span class="n">Nr</span><span class="p">,</span> <span class="n">rmax</span><span class="p">,</span> <span class="n">Nm</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span>
                    <span class="n">n_order</span><span class="o">=</span><span class="n">n_order</span><span class="p">,</span> <span class="n">zmin</span><span class="o">=</span><span class="n">zmin</span><span class="p">,</span>
                    <span class="n">v_comoving</span><span class="o">=</span><span class="n">v_comoving</span><span class="p">,</span>
                    <span class="n">use_pml</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_pml</span><span class="p">,</span>
                    <span class="n">use_galilean</span><span class="o">=</span><span class="n">use_galilean</span><span class="p">,</span>
                    <span class="n">current_correction</span><span class="o">=</span><span class="n">current_correction</span><span class="p">,</span>
                    <span class="n">use_cuda</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_cuda</span><span class="p">,</span>
                    <span class="n">smoother</span><span class="o">=</span><span class="n">smoother</span><span class="p">,</span>
                    <span class="c1"># Only create threading buffers when running on CPU</span>
                    <span class="n">create_threading_buffers</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">use_cuda</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">)</span> <span class="p">)</span>

        <span class="c1"># Initialize the electrons and the ions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fld</span><span class="o">.</span><span class="n">interp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">Ez</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">particle_shape</span> <span class="o">=</span> <span class="n">particle_shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ptcl</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">n_e</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># - Initialize the electrons</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_new_species</span><span class="p">(</span> <span class="n">q</span><span class="o">=-</span><span class="n">e</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">m_e</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n_e</span><span class="p">,</span> <span class="n">dens_func</span><span class="o">=</span><span class="n">dens_func</span><span class="p">,</span>
                                  <span class="n">p_nz</span><span class="o">=</span><span class="n">p_nz</span><span class="p">,</span> <span class="n">p_nr</span><span class="o">=</span><span class="n">p_nr</span><span class="p">,</span> <span class="n">p_nt</span><span class="o">=</span><span class="n">p_nt</span><span class="p">,</span>
                                  <span class="n">p_zmin</span><span class="o">=</span><span class="n">p_zmin</span><span class="p">,</span> <span class="n">p_zmax</span><span class="o">=</span><span class="n">p_zmax</span><span class="p">,</span>
                                  <span class="n">p_rmin</span><span class="o">=</span><span class="n">p_rmin</span><span class="p">,</span> <span class="n">p_rmax</span><span class="o">=</span><span class="n">p_rmax</span> <span class="p">)</span>
            <span class="c1"># - Initialize the ions</span>
            <span class="k">if</span> <span class="n">initialize_ions</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_new_species</span><span class="p">(</span> <span class="n">q</span><span class="o">=</span><span class="n">e</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">m_p</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n_e</span><span class="p">,</span> <span class="n">dens_func</span><span class="o">=</span><span class="n">dens_func</span><span class="p">,</span>
                                  <span class="n">p_nz</span><span class="o">=</span><span class="n">p_nz</span><span class="p">,</span> <span class="n">p_nr</span><span class="o">=</span><span class="n">p_nr</span><span class="p">,</span> <span class="n">p_nt</span><span class="o">=</span><span class="n">p_nt</span><span class="p">,</span>
                                  <span class="n">p_zmin</span><span class="o">=</span><span class="n">p_zmin</span><span class="p">,</span> <span class="n">p_zmax</span><span class="o">=</span><span class="n">p_zmax</span><span class="p">,</span>
                                  <span class="n">p_rmin</span><span class="o">=</span><span class="n">p_rmin</span><span class="p">,</span> <span class="n">p_rmax</span><span class="o">=</span><span class="n">p_rmax</span> <span class="p">)</span>

        <span class="c1"># Register the time and the iteration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Register the filtering flag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filter_currents</span> <span class="o">=</span> <span class="n">filter_currents</span>

        <span class="c1"># Initialize an empty list of external fields</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">external_fields</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Initialize an empty list of diagnostics and checkpoints</span>
        <span class="c1"># (Checkpoints are used for restarting the simulation)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diags</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checkpoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Initialize an empty list of laser antennas</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">laser_antennas</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Print simulation setup</span>
        <span class="n">print_simulation_setup</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">verbose_level</span><span class="o">=</span><span class="n">verbose_level</span> <span class="p">)</span>

<div class="viewcode-block" id="Simulation.step"><a class="viewcode-back" href="../../api_reference/simulation.html#fbpic.main.Simulation.step">[docs]</a>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">correct_currents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
             <span class="n">correct_divE</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_true_rho</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">move_positions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">move_momenta</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">show_progress</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform N PIC cycles.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        N: int, optional</span>
<span class="sd">            The number of timesteps to take</span>
<span class="sd">            Default: N=1</span>

<span class="sd">        correct_currents: bool, optional</span>
<span class="sd">            Whether to correct the currents in spectral space</span>

<span class="sd">        correct_divE: bool, optional</span>
<span class="sd">            Whether to correct the divergence of E in spectral space</span>

<span class="sd">        use_true_rho: bool, optional</span>
<span class="sd">            Whether to use the true rho deposited on the grid for the</span>
<span class="sd">            field push or not. (requires initialize_ions = True)</span>

<span class="sd">        move_positions: bool, optional</span>
<span class="sd">            Whether to move or freeze the particles&#39; positions</span>

<span class="sd">        move_momenta: bool, optional</span>
<span class="sd">            Whether to move or freeze the particles&#39; momenta</span>

<span class="sd">        show_progress: bool, optional</span>
<span class="sd">            Whether to show a progression bar</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Shortcuts</span>
        <span class="n">ptcl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptcl</span>
        <span class="n">fld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fld</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
        <span class="c1"># Sanity check</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">correct_divE</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;correct_divE cannot be used in multi-proc mode.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">use_true_rho</span> <span class="ow">and</span> <span class="n">correct_currents</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`use_true_rho` cannot be used together &#39;</span>
                            <span class="s1">&#39;with `correct_currents` in multi-proc mode.&#39;</span><span class="p">)</span>
            <span class="c1"># This is because use_true_rho requires the guard cells of</span>
            <span class="c1"># rho to be exchanged while correct_currents requires the opposite.</span>

        <span class="c1"># Initialize the positions for continuous injection by moving window</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">moving_win</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">species</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptcl</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">species</span><span class="o">.</span><span class="n">continuous_injection</span><span class="p">:</span>
                    <span class="n">species</span><span class="o">.</span><span class="n">injector</span><span class="o">.</span><span class="n">initialize_injection_positions</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">moving_win</span><span class="o">.</span><span class="n">v</span><span class="p">,</span> <span class="n">species</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="p">)</span>

        <span class="c1"># Initialize variables to measure the time taken by the simulation</span>
        <span class="k">if</span> <span class="n">show_progress</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">progress_bar</span> <span class="o">=</span> <span class="n">ProgressBar</span><span class="p">(</span> <span class="n">N</span> <span class="p">)</span>

        <span class="c1"># Send simulation data to GPU (if CUDA is used)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_cuda</span><span class="p">:</span>
            <span class="n">send_data_to_gpu</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Get the E and B fields in spectral space initially</span>
        <span class="c1"># (In the rest of the loop, E and B will only be transformed</span>
        <span class="c1"># from spectal space to real space, but never the other way around)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">exchange_fields</span><span class="p">(</span><span class="n">fld</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">exchange_fields</span><span class="p">(</span><span class="n">fld</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">damp_EB_open_boundary</span><span class="p">(</span> <span class="n">fld</span><span class="o">.</span><span class="n">interp</span> <span class="p">)</span>
        <span class="n">fld</span><span class="o">.</span><span class="n">interp2spect</span><span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">)</span>
        <span class="n">fld</span><span class="o">.</span><span class="n">interp2spect</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_pml</span><span class="p">:</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">interp2spect</span><span class="p">(</span><span class="s1">&#39;E_pml&#39;</span><span class="p">)</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">interp2spect</span><span class="p">(</span><span class="s1">&#39;B_pml&#39;</span><span class="p">)</span>

        <span class="c1"># Beginning of the N iterations</span>
        <span class="c1"># -----------------------------</span>

        <span class="c1"># Loop over timesteps</span>
        <span class="k">for</span> <span class="n">i_step</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>

            <span class="c1"># Show a progression bar and calculate ETA</span>
            <span class="k">if</span> <span class="n">show_progress</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">progress_bar</span><span class="o">.</span><span class="n">time</span><span class="p">(</span> <span class="n">i_step</span> <span class="p">)</span>
                <span class="n">progress_bar</span><span class="o">.</span><span class="n">print_progress</span><span class="p">()</span>

            <span class="c1"># Particle exchanges to prepare for this iteration</span>
            <span class="c1"># ------------------------------------------------</span>

            <span class="c1"># Check whether this iteration involves particle exchange.</span>
            <span class="c1"># Note: Particle exchange is imposed at the first iteration</span>
            <span class="c1"># of this loop (i_step == 0) in order to ensure that all</span>
            <span class="c1"># particles are inside the box, and that &#39;rho_prev&#39; is correct</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">exchange_period</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">i_step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Particle exchange includes MPI exchange of particles, removal</span>
                <span class="c1"># of out-of-box particles and (if there is a moving window)</span>
                <span class="c1"># continuous injection of new particles by the moving window.</span>
                <span class="c1"># (In the case of single-proc periodic simulations, particles</span>
                <span class="c1"># are shifted by one box length, so they remain inside the box)</span>
                <span class="k">for</span> <span class="n">species</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptcl</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">exchange_particles</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">fld</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">antenna</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">laser_antennas</span><span class="p">:</span>
                    <span class="n">antenna</span><span class="o">.</span><span class="n">update_current_rank</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">)</span>

                <span class="c1"># Reproject the charge on the interpolation grid</span>
                <span class="c1"># (Since particles have been removed / added to the simulation;</span>
                <span class="c1"># otherwise rho_prev is obtained from the previous iteration.)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="s1">&#39;rho_prev&#39;</span><span class="p">,</span> <span class="n">exchange</span><span class="o">=</span><span class="p">(</span><span class="n">use_true_rho</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">))</span>

            <span class="c1"># For the field diagnostics of the first step: deposit J</span>
            <span class="c1"># (Note however that this is not the *corrected* current)</span>
            <span class="k">if</span> <span class="n">i_step</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">,</span> <span class="n">exchange</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Main PIC iteration</span>
            <span class="c1"># ------------------</span>

            <span class="c1"># Keep field arrays sorted throughout gathering+push</span>
            <span class="k">for</span> <span class="n">species</span> <span class="ow">in</span> <span class="n">ptcl</span><span class="p">:</span>
                <span class="n">species</span><span class="o">.</span><span class="n">keep_fields_sorted</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Gather the fields from the grid at t = n dt</span>
            <span class="k">for</span> <span class="n">species</span> <span class="ow">in</span> <span class="n">ptcl</span><span class="p">:</span>
                <span class="n">species</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span> <span class="n">fld</span><span class="o">.</span><span class="n">interp</span> <span class="p">)</span>
            <span class="c1"># Apply the external fields at t = n dt</span>
            <span class="k">for</span> <span class="n">ext_field</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">external_fields</span><span class="p">:</span>
                <span class="n">ext_field</span><span class="o">.</span><span class="n">apply_expression</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptcl</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="p">)</span>

            <span class="c1"># Run the diagnostics</span>
            <span class="c1"># (after gathering ; allows output of gathered fields on particles)</span>
            <span class="c1"># (E, B, rho, x are defined at time n ; J, p at time n-1/2)</span>
            <span class="k">for</span> <span class="n">diag</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">diags</span><span class="p">:</span>
                <span class="c1"># Check if the diagnostic should be written at this iteration</span>
                <span class="c1"># (If needed: bring rho/J from spectral space, where they</span>
                <span class="c1"># were smoothed/corrected, and copy the data from the GPU.)</span>
                <span class="n">diag</span><span class="o">.</span><span class="n">write</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="p">)</span>

            <span class="c1"># Push the particles&#39; positions and velocities to t = (n+1/2) dt</span>
            <span class="k">if</span> <span class="n">move_momenta</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">species</span> <span class="ow">in</span> <span class="n">ptcl</span><span class="p">:</span>
                    <span class="n">species</span><span class="o">.</span><span class="n">push_p</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">move_positions</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">species</span> <span class="ow">in</span> <span class="n">ptcl</span><span class="p">:</span>
                    <span class="n">species</span><span class="o">.</span><span class="n">push_x</span><span class="p">(</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span> <span class="p">)</span>
            <span class="c1"># Get positions/velocities for antenna particles at t = (n+1/2) dt</span>
            <span class="k">for</span> <span class="n">antenna</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">laser_antennas</span><span class="p">:</span>
                <span class="n">antenna</span><span class="o">.</span><span class="n">update_v</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span> <span class="p">)</span>
                <span class="n">antenna</span><span class="o">.</span><span class="n">push_x</span><span class="p">(</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span> <span class="p">)</span>
            <span class="c1"># Shift the boundaries of the grid for the Galilean frame</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_galilean</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shift_galilean_boundaries</span><span class="p">(</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span> <span class="p">)</span>

            <span class="c1"># Handle elementary processes at t = (n + 1/2)dt</span>
            <span class="c1"># i.e. when the particles&#39; velocity and position are synchronized</span>
            <span class="c1"># (e.g. ionization, Compton scattering, ...)</span>
            <span class="k">for</span> <span class="n">species</span> <span class="ow">in</span> <span class="n">ptcl</span><span class="p">:</span>
                <span class="n">species</span><span class="o">.</span><span class="n">handle_elementary_processes</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span> <span class="p">)</span>

            <span class="c1"># Fields are not used beyond this point ; no need to keep sorted</span>
            <span class="k">for</span> <span class="n">species</span> <span class="ow">in</span> <span class="n">ptcl</span><span class="p">:</span>
                <span class="n">species</span><span class="o">.</span><span class="n">keep_fields_sorted</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># Get the current at t = (n+1/2) dt</span>
            <span class="c1"># (Guard cell exchange done either now or after current correction)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">,</span> <span class="n">exchange</span><span class="o">=</span><span class="p">(</span><span class="n">correct_currents</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">))</span>
            <span class="c1"># Perform cross-deposition if needed</span>
            <span class="k">if</span> <span class="n">correct_currents</span> <span class="ow">and</span> <span class="n">fld</span><span class="o">.</span><span class="n">current_correction</span><span class="o">==</span><span class="s1">&#39;cross-deposition&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cross_deposit</span><span class="p">(</span> <span class="n">move_positions</span> <span class="p">)</span>

            <span class="c1"># Push the particles&#39; positions to t = (n+1) dt</span>
            <span class="k">if</span> <span class="n">move_positions</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">species</span> <span class="ow">in</span> <span class="n">ptcl</span><span class="p">:</span>
                    <span class="n">species</span><span class="o">.</span><span class="n">push_x</span><span class="p">(</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span> <span class="p">)</span>
            <span class="c1"># Get positions for antenna particles at t = (n+1) dt</span>
            <span class="k">for</span> <span class="n">antenna</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">laser_antennas</span><span class="p">:</span>
                <span class="n">antenna</span><span class="o">.</span><span class="n">push_x</span><span class="p">(</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span> <span class="p">)</span>
            <span class="c1"># Shift the boundaries of the grid for the Galilean frame</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_galilean</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">shift_galilean_boundaries</span><span class="p">(</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span> <span class="p">)</span>

            <span class="c1"># Get the charge density at t = (n+1) dt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span><span class="s1">&#39;rho_next&#39;</span><span class="p">,</span> <span class="n">exchange</span><span class="o">=</span><span class="p">(</span><span class="n">use_true_rho</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">))</span>
            <span class="c1"># Correct the currents (requires rho at t = (n+1) dt )</span>
            <span class="k">if</span> <span class="n">correct_currents</span><span class="p">:</span>
                <span class="n">fld</span><span class="o">.</span><span class="n">correct_currents</span><span class="p">(</span> <span class="n">check_exchanges</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Exchange the guard cells of corrected J between domains</span>
                    <span class="c1"># (If correct_currents is False, the exchange of J</span>
                    <span class="c1"># is done in the function `deposit`)</span>
                    <span class="n">fld</span><span class="o">.</span><span class="n">spect2partial_interp</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">exchange_fields</span><span class="p">(</span><span class="n">fld</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span><span class="p">,</span> <span class="s1">&#39;add&#39;</span><span class="p">)</span>
                    <span class="n">fld</span><span class="o">.</span><span class="n">partial_interp2spect</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">)</span>
                <span class="n">fld</span><span class="o">.</span><span class="n">exchanged_source</span><span class="p">[</span><span class="s1">&#39;J&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Push the fields E and B on the spectral grid to t = (n+1) dt</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">push</span><span class="p">(</span> <span class="n">use_true_rho</span><span class="p">,</span> <span class="n">check_exchanges</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">if</span> <span class="n">correct_divE</span><span class="p">:</span>
                <span class="n">fld</span><span class="o">.</span><span class="n">correct_divE</span><span class="p">()</span>
            <span class="c1"># Move the grids if needed</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">moving_win</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Shift the fields is spectral space and update positions of</span>
                <span class="c1"># the interpolation grids</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">move_grids</span><span class="p">(</span><span class="n">fld</span><span class="p">,</span> <span class="n">ptcl</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span><span class="p">)</span>

            <span class="c1"># Handle boundaries for the E and B fields:</span>
            <span class="c1"># - MPI exchanges for guard cells</span>
            <span class="c1"># - Damp fields in damping cells</span>
            <span class="c1"># - Update the fields in interpolation space</span>
            <span class="c1">#  (needed for the field gathering at the next iteration)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exchange_and_damp_EB</span><span class="p">()</span>

            <span class="c1"># Increment the global time and iteration</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">+=</span> <span class="n">dt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Write the checkpoints if needed</span>
            <span class="k">for</span> <span class="n">checkpoint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">checkpoints</span><span class="p">:</span>
                <span class="n">checkpoint</span><span class="o">.</span><span class="n">write</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">iteration</span> <span class="p">)</span>

        <span class="c1"># End of the N iterations</span>
        <span class="c1"># -----------------------</span>

        <span class="c1"># Finalize PIC loop</span>
        <span class="c1"># Get the charge density and the current from spectral space.</span>
        <span class="n">fld</span><span class="o">.</span><span class="n">spect2interp</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">fld</span><span class="o">.</span><span class="n">exchanged_source</span><span class="p">[</span><span class="s1">&#39;J&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">exchange_fields</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fld</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span><span class="p">,</span> <span class="s1">&#39;add&#39;</span><span class="p">)</span>
        <span class="n">fld</span><span class="o">.</span><span class="n">spect2interp</span><span class="p">(</span><span class="s1">&#39;rho_prev&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">fld</span><span class="o">.</span><span class="n">exchanged_source</span><span class="p">[</span><span class="s1">&#39;rho_prev&#39;</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">exchange_fields</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fld</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span> <span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="s1">&#39;add&#39;</span><span class="p">)</span>

        <span class="c1"># Receive simulation data from GPU (if CUDA is used)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_cuda</span><span class="p">:</span>
            <span class="n">receive_data_from_gpu</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Print the measured time taken by the PIC cycle</span>
        <span class="k">if</span> <span class="n">show_progress</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span><span class="o">==</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">progress_bar</span><span class="o">.</span><span class="n">print_summary</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">deposit</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">fieldtype</span><span class="p">,</span> <span class="n">exchange</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">update_spectral</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">species_list</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deposit the charge or the currents to the interpolation grid</span>
<span class="sd">        and then to the spectral grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fieldtype: str</span>
<span class="sd">            The designation of the spectral field that</span>
<span class="sd">            should be changed by the deposition</span>
<span class="sd">            Either &#39;rho_prev&#39;, &#39;rho_next&#39; or &#39;J&#39;</span>
<span class="sd">            (or &#39;rho_next_xy&#39; and &#39;rho_next_z&#39; for cross-deposition)</span>

<span class="sd">        exchange: bool</span>
<span class="sd">            Whether to exchange guard cells via MPI before transforming</span>
<span class="sd">            the fields to the spectral grid. (The corresponding flag in</span>
<span class="sd">            fld.exchanged_source is set accordingly.)</span>

<span class="sd">        update_spectral: bool</span>
<span class="sd">            Whether to update the value of the deposited field in</span>
<span class="sd">            spectral space.</span>

<span class="sd">        species_list: list of `Particles` objects, or None</span>
<span class="sd">            The species which that should deposit their charge/current.</span>
<span class="sd">            If this is None, all species (and antennas) deposit.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Shortcut</span>
        <span class="n">fld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fld</span>
        <span class="c1"># If no species_list is provided, all species and antennas deposit</span>
        <span class="k">if</span> <span class="n">species_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">species_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptcl</span>
            <span class="n">antennas_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">laser_antennas</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Otherwise only the specified species deposit</span>
            <span class="n">antennas_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Deposit charge or currents on the interpolation grid</span>

        <span class="c1"># Charge</span>
        <span class="k">if</span> <span class="n">fieldtype</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">):</span>  <span class="c1"># e.g. rho_next, rho_prev, etc.</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">)</span>
            <span class="c1"># Deposit the particle charge</span>
            <span class="k">for</span> <span class="n">species</span> <span class="ow">in</span> <span class="n">species_list</span><span class="p">:</span>
                <span class="n">species</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span> <span class="n">fld</span><span class="p">,</span> <span class="s1">&#39;rho&#39;</span> <span class="p">)</span>
            <span class="c1"># Deposit the charge of the virtual particles in the antenna</span>
            <span class="k">for</span> <span class="n">antenna</span> <span class="ow">in</span> <span class="n">antennas_list</span><span class="p">:</span>
                <span class="n">antenna</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span> <span class="n">fld</span><span class="p">,</span> <span class="s1">&#39;rho&#39;</span> <span class="p">)</span>
            <span class="c1"># Sum contribution from each CPU threads (skipped on GPU)</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">sum_reduce_deposition_array</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">)</span>
            <span class="c1"># Divide by cell volume</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">divide_by_volume</span><span class="p">(</span><span class="s1">&#39;rho&#39;</span><span class="p">)</span>
            <span class="c1"># Exchange guard cells if requested by the user</span>
            <span class="k">if</span> <span class="n">exchange</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">exchange_fields</span><span class="p">(</span><span class="n">fld</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span> <span class="s1">&#39;rho&#39;</span><span class="p">,</span> <span class="s1">&#39;add&#39;</span><span class="p">)</span>

        <span class="c1"># Currents</span>
        <span class="k">elif</span> <span class="n">fieldtype</span> <span class="o">==</span> <span class="s1">&#39;J&#39;</span><span class="p">:</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">erase</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">)</span>
            <span class="c1"># Deposit the particle current</span>
            <span class="k">for</span> <span class="n">species</span> <span class="ow">in</span> <span class="n">species_list</span><span class="p">:</span>
                <span class="n">species</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span> <span class="n">fld</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span> <span class="p">)</span>
            <span class="c1"># Deposit the current of the virtual particles in the antenna</span>
            <span class="k">for</span> <span class="n">antenna</span> <span class="ow">in</span> <span class="n">antennas_list</span><span class="p">:</span>
                <span class="n">antenna</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span> <span class="n">fld</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span> <span class="p">)</span>
            <span class="c1"># Sum contribution from each CPU threads (skipped on GPU)</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">sum_reduce_deposition_array</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">)</span>
            <span class="c1"># Divide by cell volume</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">divide_by_volume</span><span class="p">(</span><span class="s1">&#39;J&#39;</span><span class="p">)</span>
            <span class="c1"># Exchange guard cells if requested by the user</span>
            <span class="k">if</span> <span class="n">exchange</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">exchange_fields</span><span class="p">(</span><span class="n">fld</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span> <span class="s1">&#39;J&#39;</span><span class="p">,</span> <span class="s1">&#39;add&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown fieldtype: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span><span class="n">fieldtype</span><span class="p">)</span>

        <span class="c1"># Get the charge or currents on the spectral grid</span>
        <span class="k">if</span> <span class="n">update_spectral</span><span class="p">:</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">interp2spect</span><span class="p">(</span> <span class="n">fieldtype</span> <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">filter_currents</span><span class="p">:</span>
                <span class="n">fld</span><span class="o">.</span><span class="n">filter_spect</span><span class="p">(</span> <span class="n">fieldtype</span> <span class="p">)</span>
            <span class="c1"># Set the flag to indicate whether these fields have been exchanged</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">exchanged_source</span><span class="p">[</span> <span class="n">fieldtype</span> <span class="p">]</span> <span class="o">=</span> <span class="n">exchange</span>

    <span class="k">def</span> <span class="nf">cross_deposit</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">move_positions</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform cross-deposition. This function should be called</span>
<span class="sd">        when the particles are at time n+1/2.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        move_positions:bool</span>
<span class="sd">            Whether to move the positions of regular particles</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>

        <span class="c1"># Push the particles: z[n+1/2], x[n+1/2] =&gt; z[n], x[n+1]</span>
        <span class="k">if</span> <span class="n">move_positions</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">species</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptcl</span><span class="p">:</span>
                <span class="n">species</span><span class="o">.</span><span class="n">push_x</span><span class="p">(</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">x_push</span><span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">y_push</span><span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">z_push</span><span class="o">=</span> <span class="o">-</span><span class="mf">1.</span> <span class="p">)</span>
        <span class="k">for</span> <span class="n">antenna</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">laser_antennas</span><span class="p">:</span>
            <span class="n">antenna</span><span class="o">.</span><span class="n">push_x</span><span class="p">(</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">x_push</span><span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">y_push</span><span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">z_push</span><span class="o">=</span> <span class="o">-</span><span class="mf">1.</span> <span class="p">)</span>
        <span class="c1"># Shift the boundaries of the grid for the Galilean frame</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_galilean</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shift_galilean_boundaries</span><span class="p">(</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span> <span class="p">)</span>
        <span class="c1"># Deposit rho_next_xy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span> <span class="s1">&#39;rho_next_xy&#39;</span> <span class="p">)</span>

        <span class="c1"># Push the particles: z[n], x[n+1] =&gt; z[n+1], x[n]</span>
        <span class="k">if</span> <span class="n">move_positions</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">species</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptcl</span><span class="p">:</span>
                <span class="n">species</span><span class="o">.</span><span class="n">push_x</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">x_push</span><span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">y_push</span><span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">z_push</span><span class="o">=</span> <span class="mf">1.</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">antenna</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">laser_antennas</span><span class="p">:</span>
            <span class="n">antenna</span><span class="o">.</span><span class="n">push_x</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">x_push</span><span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">y_push</span><span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="n">z_push</span><span class="o">=</span> <span class="mf">1.</span><span class="p">)</span>
        <span class="c1"># Shift the boundaries of the grid for the Galilean frame</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_galilean</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shift_galilean_boundaries</span><span class="p">(</span> <span class="n">dt</span> <span class="p">)</span>
        <span class="c1"># Deposit rho_next_z</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deposit</span><span class="p">(</span> <span class="s1">&#39;rho_next_z&#39;</span> <span class="p">)</span>

        <span class="c1"># Push the particles: z[n+1], x[n] =&gt; z[n+1/2], x[n+1/2]</span>
        <span class="k">if</span> <span class="n">move_positions</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">species</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptcl</span><span class="p">:</span>
                <span class="n">species</span><span class="o">.</span><span class="n">push_x</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">x_push</span><span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">y_push</span><span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">z_push</span><span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">antenna</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">laser_antennas</span><span class="p">:</span>
            <span class="n">antenna</span><span class="o">.</span><span class="n">push_x</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span> <span class="n">x_push</span><span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">y_push</span><span class="o">=</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">z_push</span><span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
        <span class="c1"># Shift the boundaries of the grid for the Galilean frame</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_galilean</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shift_galilean_boundaries</span><span class="p">(</span> <span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">dt</span> <span class="p">)</span>


    <span class="k">def</span> <span class="nf">exchange_and_damp_EB</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handle boundaries for the E and B fields:</span>
<span class="sd">         - MPI exchanges for guard cells</span>
<span class="sd">         - Damp fields in damping cells (in z, and in r if PML are used)</span>
<span class="sd">         - Update the fields in interpolation space</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Shortcut</span>
        <span class="n">fld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fld</span>

        <span class="c1"># - Get fields in interpolation space (or partial interpolation space)</span>
        <span class="c1">#   to prepare for damp/exchange</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_pml</span><span class="p">:</span>
            <span class="c1"># Exchange/damp operation in z and r ; do full transform</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">spect2interp</span><span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">)</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">spect2interp</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">spect2interp</span><span class="p">(</span><span class="s1">&#39;E_pml&#39;</span><span class="p">)</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">spect2interp</span><span class="p">(</span><span class="s1">&#39;B_pml&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Exchange/damp operation is purely along z; spectral fields</span>
            <span class="c1"># are updated by doing an iFFT/FFT instead of a full transform</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">spect2partial_interp</span><span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">)</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">spect2partial_interp</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>

        <span class="c1"># - Exchange guard cells and damp fields</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">exchange_fields</span><span class="p">(</span><span class="n">fld</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">exchange_fields</span><span class="p">(</span><span class="n">fld</span><span class="o">.</span><span class="n">interp</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;replace&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">damp_EB_open_boundary</span><span class="p">(</span> <span class="n">fld</span><span class="o">.</span><span class="n">interp</span> <span class="p">)</span> <span class="c1"># Damp along z</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_pml</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">damp_pml_EB</span><span class="p">(</span> <span class="n">fld</span><span class="o">.</span><span class="n">interp</span> <span class="p">)</span> <span class="c1"># Damp in radial PML</span>

        <span class="c1"># - Update spectral space (and interpolation space if needed)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_pml</span><span class="p">:</span>
            <span class="c1"># Exchange/damp operation in z and r ; do full transform back</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">interp2spect</span><span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">)</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">interp2spect</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">interp2spect</span><span class="p">(</span><span class="s1">&#39;E_pml&#39;</span><span class="p">)</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">interp2spect</span><span class="p">(</span><span class="s1">&#39;B_pml&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Exchange/damp operation is purely along z; spectral fields</span>
            <span class="c1"># are updated by doing an iFFT/FFT instead of a full transform</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">partial_interp2spect</span><span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">)</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">partial_interp2spect</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>
            <span class="c1"># Get the corresponding fields in interpolation space</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">spect2interp</span><span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">)</span>
            <span class="n">fld</span><span class="o">.</span><span class="n">spect2interp</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">shift_galilean_boundaries</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shift the interpolation grids by v_comoving * dt.</span>
<span class="sd">        (The field arrays are unchanged, only position attributes are changed.)</span>

<span class="sd">        With the Galilean frame, in principle everything should</span>
<span class="sd">        be solved in variables xi = z - v_comoving t, and -v_comoving</span>
<span class="sd">        should be added to the motion of the particles. However, it</span>
<span class="sd">        is equivalent to, instead, shift the boundaries of the grid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate shift distance over a half timestep</span>
        <span class="n">shift_distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">v_comoving</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="c1"># Shift the boundaries of the global domain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">shift_global_domain_positions</span><span class="p">(</span> <span class="n">shift_distance</span> <span class="p">)</span>
        <span class="c1"># Shift the boundaries of the grid</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fld</span><span class="o">.</span><span class="n">Nm</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fld</span><span class="o">.</span><span class="n">interp</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">zmin</span> <span class="o">+=</span> <span class="n">shift_distance</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fld</span><span class="o">.</span><span class="n">interp</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">zmax</span> <span class="o">+=</span> <span class="n">shift_distance</span>


<div class="viewcode-block" id="Simulation.add_new_species"><a class="viewcode-back" href="../../api_reference/simulation.html#fbpic.main.Simulation.add_new_species">[docs]</a>    <span class="k">def</span> <span class="nf">add_new_species</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dens_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">p_nz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p_nr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">p_nt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">p_zmin</span><span class="o">=-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">p_zmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                            <span class="n">p_rmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">p_rmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                            <span class="n">uz_m</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">ux_m</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">uy_m</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
                            <span class="n">uz_th</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">ux_th</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">uy_th</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span>
                            <span class="n">continuous_injection</span><span class="o">=</span><span class="kc">True</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new species (i.e. an instance of `Particles`) with</span>
<span class="sd">        charge `q` and mass `m`. Add it to the simulation (i.e. to the list</span>
<span class="sd">        `Simulation.ptcl`), and return it, so that the methods of the</span>
<span class="sd">        `Particles` class can be used, for this particular species.</span>

<span class="sd">        In addition, if `n` is set, then new macroparticles will be created</span>
<span class="sd">        within this species (in an evenly-spaced manner).</span>

<span class="sd">        For boosted-frame simulations (i.e. where `gamma_boost`</span>
<span class="sd">        as been passed to the `Simulation` object), all quantities that</span>
<span class="sd">        are explicitly mentioned to be in the lab frame below are</span>
<span class="sd">        automatically converted to the boosted frame.</span>

<span class="sd">        .. note::</span>

<span class="sd">            For the arguments below, it is recommended to have at least</span>
<span class="sd">            ``p_nt = 4*Nm`` (except in the case ``Nm=1``, for which</span>
<span class="sd">            ``p_nt=1`` is sufficient). In other words, the required number of</span>
<span class="sd">            macroparticles along `theta` (in order for the simulation to be</span>
<span class="sd">            properly resolved) increases with the number of azimuthal modes used.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q : float (in Coulombs)</span>
<span class="sd">           Charge of the particle species</span>

<span class="sd">        m : float (in kg)</span>
<span class="sd">           Mass of the particle species</span>

<span class="sd">        n : float (in particles per m^3) or `None`, optional</span>
<span class="sd">           Density of physical particles (in the lab frame).</span>
<span class="sd">           If this is `None`, no macroparticles will be created.</span>
<span class="sd">           If `n` is not None, evenly-spaced macroparticles will be generated.</span>

<span class="sd">        dens_func : callable, optional</span>
<span class="sd">           A function of the form :</span>
<span class="sd">           def dens_func( z, r ) ...</span>
<span class="sd">           where z and r are 1d arrays, and which returns</span>
<span class="sd">           a 1d array containing the density *relative to n*</span>
<span class="sd">           (i.e. a number between 0 and 1) at the given positions</span>

<span class="sd">        p_nz: int, optional</span>
<span class="sd">            The number of macroparticles per cell along the z direction</span>
<span class="sd">        p_nr: int, optional</span>
<span class="sd">            The number of macroparticles per cell along the r direction</span>
<span class="sd">        p_nt: int, optional</span>
<span class="sd">            The number of macroparticles along the theta direction</span>

<span class="sd">        p_zmin: float (in meters), optional</span>
<span class="sd">            The minimal z position above which the particles are initialized</span>
<span class="sd">            (in the lab frame). Default: left edge of the simulation box.</span>
<span class="sd">        p_zmax: float (in meters), optional</span>
<span class="sd">            The maximal z position below which the particles are initialized</span>
<span class="sd">            (in the lab frame). Default: right edge of the simulation box.</span>
<span class="sd">        p_rmin: float (in meters), optional</span>
<span class="sd">            The minimal r position above which the particles are initialized</span>
<span class="sd">            (in the lab frame). Default: 0</span>
<span class="sd">        p_rmax: floats (in meters), optional</span>
<span class="sd">            The maximal r position below which the particles are initialized</span>
<span class="sd">            (in the lab frame). Default: upper edge of the simulation box.</span>

<span class="sd">        uz_m, ux_m, uy_m: floats (dimensionless), optional</span>
<span class="sd">           Normalized mean momenta (in the lab frame)</span>
<span class="sd">           of the injected particles in each direction</span>

<span class="sd">        uz_th, ux_th, uy_th: floats (dimensionless), optional</span>
<span class="sd">           Normalized thermal momenta (in the lab frame)</span>
<span class="sd">           in each direction</span>

<span class="sd">        continuous_injection : bool, optional</span>
<span class="sd">           Whether to continuously inject the particles,</span>
<span class="sd">           in the case of a moving window</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        new_species: an instance of the `Particles` class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if any macroparticle need to be injected</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Check that all required arguments are passed</span>
            <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="p">[</span><span class="n">p_nz</span><span class="p">,</span> <span class="n">p_nr</span><span class="p">,</span> <span class="n">p_nt</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">var</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;If the density `n` is passed to `add_new_species`,</span><span class="se">\n</span><span class="s1">&#39;</span>
                    <span class="s1">&#39;then the arguments `p_nz`, `p_nr` and `p_nt` need &#39;</span>
                    <span class="s1">&#39;to be passed too.&#39;</span><span class="p">)</span>

            <span class="c1"># Automatically convert input quantities to the boosted frame</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">boost</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">gamma_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span> <span class="o">+</span> <span class="n">uz_m</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">ux_m</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">uy_m</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">beta_m</span> <span class="o">=</span> <span class="n">uz_m</span><span class="o">/</span><span class="n">gamma_m</span>
                <span class="c1"># Transform positions and density</span>
                <span class="n">p_zmin</span><span class="p">,</span> <span class="n">p_zmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boost</span><span class="o">.</span><span class="n">copropag_length</span><span class="p">(</span>
                    <span class="p">[</span> <span class="n">p_zmin</span><span class="p">,</span> <span class="n">p_zmax</span> <span class="p">],</span> <span class="n">beta_object</span><span class="o">=</span><span class="n">beta_m</span> <span class="p">)</span>
                <span class="n">n</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boost</span><span class="o">.</span><span class="n">copropag_density</span><span class="p">([</span> <span class="n">n</span> <span class="p">],</span> <span class="n">beta_object</span><span class="o">=</span><span class="n">beta_m</span> <span class="p">)</span>
                <span class="c1"># Transform longitudinal thermal velocity</span>
                <span class="c1"># The formulas below are approximate, and are obtained</span>
                <span class="c1"># by perturbation of the Lorentz transform for uz</span>
                <span class="k">if</span> <span class="n">uz_m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">uz_th</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;The thermal distribution is approximate in &quot;</span>
                        <span class="s2">&quot;boosted-frame simulations, and may not be accurate &quot;</span>
                        <span class="s2">&quot;enough for uz_th &gt; 0.1&quot;</span><span class="p">)</span>
                    <span class="n">uz_th</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boost</span><span class="o">.</span><span class="n">gamma0</span> <span class="o">*</span> <span class="n">uz_th</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">uz_th</span> <span class="o">&gt;</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">uz_m</span><span class="p">:</span>
                        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;The thermal distribution is approximate in &quot;</span>
                        <span class="s2">&quot;boosted-frame simulations, and may not be accurate &quot;</span>
                        <span class="s2">&quot;enough for uz_th &gt; 0.1 * uz_m&quot;</span><span class="p">)</span>
                    <span class="n">uz_th</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boost</span><span class="o">.</span><span class="n">gamma0</span> <span class="o">*</span> \
                            <span class="p">(</span><span class="mf">1.</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">boost</span><span class="o">.</span><span class="n">beta0</span><span class="o">*</span><span class="n">beta_m</span><span class="p">)</span> <span class="o">*</span> <span class="n">uz_th</span>
                <span class="c1"># Finally transform the longitudinal momentum</span>
                <span class="n">uz_m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boost</span><span class="o">.</span><span class="n">gamma0</span><span class="o">*</span><span class="p">(</span> <span class="n">uz_m</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">boost</span><span class="o">.</span><span class="n">beta0</span><span class="o">*</span><span class="n">gamma_m</span> <span class="p">)</span>

            <span class="c1"># Modify input particle bounds, in order to only initialize the</span>
            <span class="c1"># particles in the local sub-domain</span>
            <span class="n">zmin_local_domain</span><span class="p">,</span> <span class="n">zmax_local_domain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">get_zmin_zmax</span><span class="p">(</span>
                                        <span class="n">local</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rank</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">rank</span><span class="p">,</span>
                                        <span class="n">with_damp</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">with_guard</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
            <span class="n">p_zmin</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">zmin_local_domain</span><span class="p">,</span> <span class="n">p_zmin</span> <span class="p">)</span>
            <span class="n">p_zmax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span> <span class="n">zmax_local_domain</span><span class="p">,</span> <span class="n">p_zmax</span> <span class="p">)</span>
            <span class="c1"># Avoid that particles get initialized in the radial PML cells</span>
            <span class="n">rmax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">get_rmax</span><span class="p">(</span> <span class="n">with_damp</span><span class="o">=</span><span class="kc">False</span> <span class="p">)</span>
            <span class="n">p_rmax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span> <span class="n">rmax</span><span class="p">,</span> <span class="n">p_rmax</span> <span class="p">)</span>

            <span class="c1"># Modify again the input particle bounds, so that</span>
            <span class="c1"># they fall exactly on the grid, and infer the number of particles</span>
            <span class="n">p_zmin</span><span class="p">,</span> <span class="n">p_zmax</span><span class="p">,</span> <span class="n">Npz</span> <span class="o">=</span> <span class="n">adapt_to_grid</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">fld</span><span class="o">.</span><span class="n">interp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">z</span><span class="p">,</span>
                                <span class="n">p_zmin</span><span class="p">,</span> <span class="n">p_zmax</span><span class="p">,</span> <span class="n">p_nz</span> <span class="p">)</span>
            <span class="n">p_rmin</span><span class="p">,</span> <span class="n">p_rmax</span><span class="p">,</span> <span class="n">Npr</span> <span class="o">=</span> <span class="n">adapt_to_grid</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">fld</span><span class="o">.</span><span class="n">interp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">r</span><span class="p">,</span>
                                <span class="n">p_rmin</span><span class="p">,</span> <span class="n">p_rmax</span><span class="p">,</span> <span class="n">p_nr</span> <span class="p">)</span>
            <span class="n">dz_particles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">dz</span><span class="o">/</span><span class="n">p_nz</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Check consistency of arguments</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">dens_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">p_nz</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> \
                <span class="p">(</span><span class="n">p_nr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">p_nt</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s1">&#39;It seems that you provided the arguments `dens_func`, &#39;</span>
                    <span class="s1">&#39;`p_nz`, `p_nr` or `p_nz`</span><span class="se">\n</span><span class="s1">However no particle density &#39;</span>
                    <span class="s1">&#39;(`n` or `n_e`) was given.</span><span class="se">\n</span><span class="s1">Therefore, no particles will&#39;</span>
                    <span class="s1">&#39;be created.&#39;</span><span class="p">)</span>
            <span class="c1"># Convert arguments to acceptable arguments for `Particles`</span>
            <span class="c1"># but which will result in no macroparticles being injected</span>
            <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">p_zmin</span> <span class="o">=</span> <span class="n">p_zmax</span> <span class="o">=</span> <span class="n">p_rmin</span> <span class="o">=</span> <span class="n">p_rmax</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">Npz</span> <span class="o">=</span> <span class="n">Npr</span> <span class="o">=</span> <span class="n">p_nt</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">continuous_injection</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">dz_particles</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1"># Create the new species</span>
        <span class="n">new_species</span> <span class="o">=</span> <span class="n">Particles</span><span class="p">(</span> <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">dens_func</span><span class="o">=</span><span class="n">dens_func</span><span class="p">,</span>
                        <span class="n">Npz</span><span class="o">=</span><span class="n">Npz</span><span class="p">,</span> <span class="n">zmin</span><span class="o">=</span><span class="n">p_zmin</span><span class="p">,</span> <span class="n">zmax</span><span class="o">=</span><span class="n">p_zmax</span><span class="p">,</span>
                        <span class="n">Npr</span><span class="o">=</span><span class="n">Npr</span><span class="p">,</span> <span class="n">rmin</span><span class="o">=</span><span class="n">p_rmin</span><span class="p">,</span> <span class="n">rmax</span><span class="o">=</span><span class="n">p_rmax</span><span class="p">,</span>
                        <span class="n">Nptheta</span><span class="o">=</span><span class="n">p_nt</span><span class="p">,</span> <span class="n">dt</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span>
                        <span class="n">particle_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">particle_shape</span><span class="p">,</span>
                        <span class="n">use_cuda</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">use_cuda</span><span class="p">,</span> <span class="n">grid_shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_shape</span><span class="p">,</span>
                        <span class="n">ux_m</span><span class="o">=</span><span class="n">ux_m</span><span class="p">,</span> <span class="n">uy_m</span><span class="o">=</span><span class="n">uy_m</span><span class="p">,</span> <span class="n">uz_m</span><span class="o">=</span><span class="n">uz_m</span><span class="p">,</span>
                        <span class="n">ux_th</span><span class="o">=</span><span class="n">ux_th</span><span class="p">,</span> <span class="n">uy_th</span><span class="o">=</span><span class="n">uy_th</span><span class="p">,</span> <span class="n">uz_th</span><span class="o">=</span><span class="n">uz_th</span><span class="p">,</span>
                        <span class="n">continuous_injection</span><span class="o">=</span><span class="n">continuous_injection</span><span class="p">,</span>
                        <span class="n">dz_particles</span><span class="o">=</span><span class="n">dz_particles</span> <span class="p">)</span>

        <span class="c1"># Add it to the list of species and return it to the user</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ptcl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="n">new_species</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">new_species</span></div>


<div class="viewcode-block" id="Simulation.set_moving_window"><a class="viewcode-back" href="../../api_reference/simulation.html#fbpic.main.Simulation.set_moving_window">[docs]</a>    <span class="k">def</span> <span class="nf">set_moving_window</span><span class="p">(</span> <span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">ux_m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">uy_m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">uz_m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">ux_th</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">uy_th</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">uz_th</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gamma_boost</span><span class="o">=</span><span class="kc">None</span> <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a moving window for the simulation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        v: float (in meters per seconds), optional</span>
<span class="sd">            The speed of the moving window</span>

<span class="sd">        ux_m, uy_m, uz_m: float (dimensionless), optional</span>
<span class="sd">            Unused, kept for backward-compatibility</span>
<span class="sd">        ux_th, uy_th, uz_th: float (dimensionless), optional</span>
<span class="sd">            Unused, kept for backward-compatibility</span>
<span class="sd">        gamma_boost : float, optional</span>
<span class="sd">            Unused; kept for backward compatibility</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Raise deprecation warning</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">[</span><span class="n">ux_m</span><span class="p">,</span> <span class="n">uy_m</span><span class="p">,</span> <span class="n">uz_m</span><span class="p">,</span> <span class="n">ux_th</span><span class="p">,</span> <span class="n">uy_th</span><span class="p">,</span> <span class="n">uz_th</span><span class="p">,</span> <span class="n">gamma_boost</span> <span class="p">]:</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;The arguments `u*_m`, `u*_th` and `gamma_boost` of &#39;</span>
                <span class="s1">&#39;the method `set_moving_window` are deprecated.</span><span class="se">\n</span><span class="s1">&#39;</span>
                <span class="s1">&#39;They will not be used.</span><span class="se">\n</span><span class="s1">To suppress this message, &#39;</span>
                <span class="s1">&#39;stop passing these arguments to `set_moving_window`&#39;</span><span class="p">,</span>
                <span class="ne">DeprecationWarning</span><span class="p">)</span>

        <span class="c1"># Attach the moving window to the boundary communicator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="o">.</span><span class="n">moving_win</span> <span class="o">=</span> <span class="n">MovingWindow</span><span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">comm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">reverse_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convenience method to reverse the direction of electromagnetic waves</span>
<span class="sd">        and particles propagation. Essentially this method inverses the signs of</span>
<span class="sd">        magnetic fields and particles momenta.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Inverse the signs of magnetic fields in spectral and real space</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fld</span><span class="o">.</span><span class="n">Nm</span><span class="p">)</span> <span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fld</span><span class="o">.</span><span class="n">spect</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">Bp</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fld</span><span class="o">.</span><span class="n">spect</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">Bm</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fld</span><span class="o">.</span><span class="n">spect</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">Bz</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">fld</span><span class="o">.</span><span class="n">interp</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">Br</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fld</span><span class="o">.</span><span class="n">interp</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">Bt</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fld</span><span class="o">.</span><span class="n">interp</span><span class="p">[</span><span class="n">m</span><span class="p">]</span><span class="o">.</span><span class="n">Bz</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># Inverse the signs of particles momenta</span>
        <span class="k">for</span> <span class="n">species</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ptcl</span><span class="p">:</span>
            <span class="n">species</span><span class="o">.</span><span class="n">ux</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">species</span><span class="o">.</span><span class="n">uy</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">species</span><span class="o">.</span><span class="n">uz</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span></div>

<span class="k">def</span> <span class="nf">adapt_to_grid</span><span class="p">(</span> <span class="n">x</span><span class="p">,</span> <span class="n">p_xmin</span><span class="p">,</span> <span class="n">p_xmax</span><span class="p">,</span> <span class="n">p_nx</span><span class="p">,</span> <span class="n">ncells_empty</span><span class="o">=</span><span class="mi">0</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adapt p_xmin and p_xmax, so that they fall exactly on the grid x</span>
<span class="sd">    Return the total number of particles, assuming p_nx particles</span>
<span class="sd">    per gridpoint</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x: 1darray</span>
<span class="sd">        The positions of the gridpoints along the x direction</span>

<span class="sd">    p_xmin, p_xmax: float</span>
<span class="sd">        The minimal and maximal position of the particles</span>
<span class="sd">        These may not fall exactly on the grid</span>

<span class="sd">    p_nx: int</span>
<span class="sd">        Number of particle per gridpoint</span>

<span class="sd">    ncells_empty: int</span>
<span class="sd">        Number of empty cells at the righthand side of the box</span>
<span class="sd">        (Typically used when using a moving window)</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    A tuple with:</span>
<span class="sd">       - p_xmin: a float that falls exactly on the grid</span>
<span class="sd">       - p_xmax: a float that falls exactly on the grid</span>
<span class="sd">       - Npx: the total number of particles</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Find the max and the step of the array</span>
    <span class="n">xmin</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">xmax</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
    <span class="n">dx</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Do not load particles below the lower bound of the box</span>
    <span class="k">if</span> <span class="n">p_xmin</span> <span class="o">&lt;</span> <span class="n">xmin</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dx</span><span class="p">:</span>
        <span class="n">p_xmin</span> <span class="o">=</span> <span class="n">xmin</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dx</span>
    <span class="c1"># Do not load particles in the two last upper cells</span>
    <span class="c1"># (This is because the charge density may extend over these cells</span>
    <span class="c1"># when it is smoothed. If particles are loaded closer to the right</span>
    <span class="c1"># boundary, this extended charge density can wrap around and appear</span>
    <span class="c1"># at the left boundary.)</span>
    <span class="k">if</span> <span class="n">p_xmax</span> <span class="o">&gt;</span> <span class="n">xmax</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">-</span><span class="n">ncells_empty</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span><span class="p">:</span>
        <span class="n">p_xmax</span> <span class="o">=</span> <span class="n">xmax</span> <span class="o">+</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">-</span><span class="n">ncells_empty</span><span class="p">)</span><span class="o">*</span><span class="n">dx</span>

    <span class="c1"># Find the gridpoints on which the particles should be loaded</span>
    <span class="n">x_load</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span> <span class="p">(</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">p_xmin</span> <span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">p_xmax</span> <span class="p">)</span> <span class="p">]</span>
    <span class="c1"># Deduce the total number of particles</span>
    <span class="n">Npx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_load</span><span class="p">)</span> <span class="o">*</span> <span class="n">p_nx</span>
    <span class="c1"># Reajust p_xmin and p_xmanx so that they match the grid</span>
    <span class="k">if</span> <span class="n">Npx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p_xmin</span> <span class="o">=</span> <span class="n">x_load</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dx</span>
        <span class="n">p_xmax</span> <span class="o">=</span> <span class="n">x_load</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">dx</span>

    <span class="k">return</span><span class="p">(</span> <span class="n">p_xmin</span><span class="p">,</span> <span class="n">p_xmax</span><span class="p">,</span> <span class="n">Npx</span> <span class="p">)</span>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, FBPIC contributors

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>